%!TEX root = ../thesis.tex

\chapter{Projekt \projectname}

In diesem Kapitel werden die Anforderungen an den praktischen Teil der Arbeit definiert.
\projectname wird im folgenden als Arbeitstitel für die Frontend Applikationen verwendet.

\section{Motivation}

Monitoring Tools dienen der Übewachung und Kontrolle bestehender Softwareprodukte.
Hierbei gibt es vielerlei Abläufe und Metriken, welche geprüft und ausgewertet werden können, um einem nutzer der Monitoring Applikation
eine aussagekräftige Übersicht über seine Systeme zu gewähren. Speziell nach dem Release eines Projektes oder nach dem Release neuer Patches
ist es meist unabdingbar das geupdatete System hinsichtlich Stabilität und Performance kritisch zu beobachten. Ein weiterer Aspekt, den es zu überwachen gilt,
ist die Skalierfähigkeit eines Produktes. Steigt die Aktivität einer Applikation, beispielsweise durch steigende Nutzerzahlen,
muss sichergestellt werden, dass steigende Antwort- und Ausfallzeiten, erkannt und richtig interpretiert werden, damit Skalierungsprobleme schnellstmöglich behoben werden können.
Handelt es sich bei dem zu überwachendem System um ein komplexes Zusammenspiel diverser Microservices, gestaltet sich die Herausforderung der manuellen Überwachung, beispielsweise anhand
Serverlogs, noch deutlich schwieriger.

Innerhalb einer Microservice Architektur ist es nicht notwendig, dass alle Services auf dem selben Server operieren.
Es ist möglich dass Services auf einer Vielzahl von Servern, womöglich an komplett unterschiedlichen geographischen Punkten miteinander agieren,
oder im Problemfall eben nicht miteinander agieren können. Instanzen einzelner Services können zur Laufzeit starten, stoppen oder womöglich abstürzen
und sollten dennoch den reibungslosen Ablauf der Applikation nicht behindern. Microservice Architekturen sind daher deutlich komplexer zu überblicken,
daher ist ein Monitoring Tool, um die Stabilität und Performance einer solchen Architektur zu gewährleisten, meist stark von Nöten.


\section{Anforderungsanalyse}

Im nachfolgenden werden Anforderungen an das umzusetzende System gestellt um das in Motivation beschriebene Problem zu lösen.

\subsection{Views}
\subsubsection{Login / Registrieren}

Dieser Screen soll erscheinen, wenn die Applikation erfolgreich geladen wurde und kein Nutzer eingeloggt ist.
Nutzer können sich mit bestehenden Accounts einloggen oder neu registrieren.
Des weiteren sollen neue Passwörter, für Nutzer die ihr bestehendes Passwort vergessen haben, angefordert werden können.
Rudimentäres Error Handling soll Nutzern im Fehlerfall auf falsche Passwörter und im Registrierfall auf
im System bereits vorhandene Mailadressen hinweisen.

\vspace{1cm}




\textbf{Login Formular}
\begin{itemize}
\item Mail (String, Valide Mailadresse, Eindeutig im System)
\item Password (String, Mindestens 3 Zeichen, Maximal 20 Zeichen)
\end{itemize}

\textbf{Register Formular}
\begin{itemize}
\item Name (String)
\item Surname (String)
\item Mail (String, Valide Mailadresse, Eindeutig im System)
\item Password (String, Mindestens 3 Zeichen, Maximal 20 Zeichen)
\end{itemize}



\vspace{1cm}

\subsubsection{System wählen / erstellen}

Da ein Nutzer mehrere aktive Systeme zeitgleich monitoren kann, benötigen wir eine übersichtsseite
um die Systeme wechseln zu können. Zusätzlich sollen neue Systeme angelegt werden können.

\vspace{1cm}
\textbf{System erstellen}

\begin{itemize}
\item Name (String, Maximal 20 Zeichen)
\item Beschreibung (String, Maximal 255 Zeichen)
\end{itemize}

\vspace{1cm}

\subsubsection{Dashboard}

Auf dem Dashboard soll ein Nutzer die wichtigsten Informationen über sein System erhalten.
Fehlerverhalten des Systems soll deutlich, dennoch informativ, dargestellt werden.
Zusätzlich soll das Dashboard als Einstiegspunkt anderer Views dienen.

\subsubsection{Metriken}

Die Metriken Sektion soll pro Applikation eine Kollektion von Diagrammen beinhalten.
Dabei soll die Applikation, so wie den aktiven Beobachtungszeitraum, gewählt werden können.

\vspace{1cm}
\textbf{Diagramme}

\begin{itemize}
\item CPU Load
\item Memory
\item Requests client send
\item Requests server receive
\end{itemize}

\vspace{1cm}

\subsubsection{Graph}

Im Vergleich zur Metrik View soll der Graph nicht nur einzelne Applikationen darstellen,
sondern das Kommunikationsnetz des Gesamtsystems visualisieren.
Dabei Sollen Services als Knoten und Requests als Kanten dargestellt werden.
Metriken, die visualisiert werden sollten, sind Anzahl und Dauer der Requests zwischen den Services.
Zusätzlich soll auch hier der Beobachtungszeitraum definiert werden können.

\subsubsection{Traces}

Die Traces Sektion soll aus zwei Views bestehen. Einer Übersichtsliste der Request Einstiegspunkte,
welche zur Trace Detaillseite überleiten soll. Im Detaill besteht ein Trace aus den Requests
aller an einer Aktion beteiligten Services. Dabei sollen die Zeitlichen Abläufe in einem Gantt Chart dargestellt werden.

\subsubsection{Settings}

In den Einstellungen sollen Nutzerrelevante Parameter definiert werden können. Metadaten sollen geändert werden können.
Nutzer sollen die Möglichkeit bekommen ein Profilbild einzustellen.


\subsection{Plattformen}
\subsubsection{Web}
\subsubsection{Desktop}
\subsubsection{Mobile}
