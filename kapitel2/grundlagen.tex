%!TEX root = ../thesis.tex

\chapter{Grundlagen}

Im nachfolgenden werden Grundlagen erläutert, die als Basis des Projekts, so wie zum Verständnis des Kapitels `Frameworks' erforderlich sind.


\section{Native Entwicklung}

Bei der Enwticklung nativer Apps, werden Applikationen speziell für eine Zielplatform mit dem entsprechendem \ac{SDK} entwickelt.
Die App ist damit an die Platform gebunden. Apps für Apples iOS werden typischerweise in Swift oder Objective-C entwickelt und nutzen UIKit als Framework für die visuelle Darstellung.
Android Apps werden typischerweise in Java implementiert und nutzen das Android Framework als Systemschnittstelle und für die entwicklung des \ac{UI}.
Nativ entwickelte Apps werden als Binärdatei über den jeweiligen Appstore verteilt und auf das Gerät installiert.\cite{Heitkoetter2013}

\vspace{1cm}
\textbf{Desktop Nativ}
\begin{itemize}
\item macOS (Swift / ObjectiveC)
\item Linux (C++, C\#, Java)
\item Windows (C++, C\#, VisualBasic, Java)
\end{itemize}

\textbf{Mobil Nativ}
\begin{itemize}
\item iOS (Swift / ObjectiveC)
\item Android (Java)
\end{itemize}

\vspace{1cm}


\section{Cross Platform Entwicklung}

Im vergleich zum Ansatz der nativen Entwicklung, bieteten diverse hybride Cross-platform Entwicklungsansätze die Möglichkeit eine Kodebasis zu entwickeln,
die auf diversen Platformen ausgeführt werden kann.\cite{Heitkoetter2013}
Hierbei muss zwischen Browserbasierten Web Apps (Cordova, Phonegap) und Cross kompilierten Applikationen (Xamarin, Titanium, FireMonkey) unterschieden werden.
\cite{Xamar84:online}

\subsection{Cross kompilierte Apps am beispiel von Xamarin}

Xamarin Entwickler, können den in C\# geschriebenen Code für die Plattformen iOS, Windows Mobile und Android kompilieren.
Der resultierende Code läuft dabei als nativer Code auf den Geräten.
Die Xamarin entwickler versprechen, dass alles was in Swift, Objective-C, Java möglich ist, auch mit C\# und Xamarin umgesetzt werden kann.\cite{projectxamarin}

\begin{figure}[ht]
 \centering
 \includegraphics[width=0.9\linewidth]{kapitel2/csharp_xamarin.png}
 \caption{Xamarin Platforms \cite{7Reas20:online}}
\end{figure}
\vspace{1cm}

Xamarin kommt bezüglich \ac{UI} schnell an seine Grenzen. Das \ac{UI} Layer muss, aufgrund von Kompatibilitätsproblemen und fehlender Features des Xamarin Framework,
für jede Platform indiviudell entwickelt werden. Das mag funktionieren, wenn die App entsprechend dem Plattform CI umgesetzt werden soll und sich die \ac{UI} so weit unterscheidet,
dass Abstraktionen und komponentenbasierte Entwicklung vernachlässibar sind, jedoch ist es fragwürdig ob sich das Framework als ``Cross Plattform Frontend Framework'' bezeichnen darf,
wenn ein Großteil der Implementierung, zumindest bei Plattfor-universellem Appdesign, nach wie vor redundant vorgenommen werden muss.\cite{7Reas20:online}

\begin{figure}[ht]
 \centering
 \includegraphics[width=0.8\linewidth]{kapitel2/xamarin_ui_blocker.png}
 \caption{Xamarin Layer \cite{7Reas20:online}}
\end{figure}

\newpage


\subsection{Web Apps (Cordova, Phonegap)}

Cordova ist ein Framework von Adobe Systems um Mobile Cross Plattform Apps mithilfe von Webtechnologien zu entwickeln.
HTML, CSS und JavaScript werden genutzt um Produkte für iOS, Android, Ubuntu, Blackberry OS, Firefox OS und Windows Phone zu generieren.\cite{Cordo26:online}
Der Code wird, im Vergleich zu mit Xamarin entwickelten Apps, nicht für verschiedene Plattformen kompiliert,
sondern in einer nativen Webview laufen gelassen. Diese Apps werden auch als hybride Apps bezeichnet.
Ionic und Phonegap sind Frameworks, die auf der Cordova Technologie aufsetzen.

Zugriff auf Systemschnittstellen erhält man mittels Cordova Plugins. Diese bieten
Interfaces in Javascript für den Zugriff auf native Systemkomponenten wie Kamera, GPS, Dateisystem etc.
Plugins bestehen daher aus Javascript und dem Plattform kompatiblen Code,
also beispielsweise Swift/Objective-C für iOS oder Java für Android.

\vspace{1cm}
\lstinputlisting[language=Java,label=code,caption=Cordova Kamera Example]{kapitel2/cordova-plugin-example.js}
\vspace{1cm}

\newpage
\section{Web Components}


\subsection{Einführung}

Moderne Webanwendungen sind heutzutage meist nicht nur in ihrem Design komplex, komplexität lässt sich auch meist nicht in der Entwicklung
von Logik vermeiden. Dieses Problem wird noch brisanter, wenn eine Applikation über einen langen Zeitraum hinweg,
womöglich von verschiedenen Entwicklerteams, entwickelt und betreut wird. Schaut man sich den DOM von Patrioten des Internets wie Facebook oder Amazon an,
wird schnell klar, dass deren Domstruktur durch Inflationäre Nutzung von DIV und SPAN Tags schnell zu Unübersicht führt,
da die Palette an HTML5 Semantic Tags nicht ausreicht, um die Funktionalitäts Vielfalt einer modernen Webanwendung abzudecken.
Statt aussagekräftige Tags zu verwenden, muss man sich mit Klassen und IDs behelfen, um HTML Elemente überhaupt voneinander unterscheiden zu können.
\cite{sitepoint-introduction-to-webcomponents}

\subsection{Komponenten in der Softwarentwicklung}

``Modern applications are increasingly
open in terms of topology,
platform and evolution, and so the
need for a component-oriented
approach to development is even
more acute than in the past [...]  Objects provide an organizational
paradigm for decomposing large
applications into cooperating objects
as well as a reuse paradigm for
composing applications from prepackaged
software components.''
\cite{nierstrasz1992component}

\vspace{0.5cm}

Bereits 1992 sprachen Nierstrasz, Gibbs und Tsichritzis von dem Traum der Komponentenorientierten Softwareentwicklung.
Dabei soll eine Software aus vielen Komponenten aufgebaut werden, im Idealfall habe man die Möglichkeit ein
ganzes Set an Komponenten für die Konstruktion seiner Applikation zu verwenden.
Hierbi soll der Aspekt der Abstraktion und Wiederverwendbarkeit durch Objektorientierung von zentraler Bedeutung sein.

\vspace{0.5cm}
``A software component is a unit of composition with contractually specified interfaces and explicit
context dependencies only. A software component can be deployed independently and is subject to composition
by third parties.''
\cite{Szyperski}
\vspace{0.5cm}

Szyperski definiert eine Komponente als eigenständiges, in sich geschlossenes Modul ohne Deployment
Abhängigkeiten. D.h. Eine Komponente kann deployed werden, ohne dass andere Bausteine der Applikation ebenfalls deployed werden müssen.
Klar definierte Schnittstellen dienen der komponentenübergeifenden Kommunikation und repräsentieren
möglichst transparent die Funktionalität der Komponente.
Komponenten sollen dabei angeboten, sei es komerziell oder gratis,
und von Dritten verwendet werden können.


\subsection{Web Components}

``Web Components are an emerging set of standards from the W3C to describe a way to create encapsulated,
reusable blocks of UI presentation and behavior entirely with client side languages- HTML, JavaScript and CSS.''
\cite[42]{Web-Component-Architecture}
\vspace{1cm}

Der W3C beschreibt diverse Wege wie entkoppelte wiederverwendbare UI Elemente,
in Kombination von HTML, JavaScript und CSS, so genannte Web Components, geschaffen werden können.
Der Begriff Web Components beinhaltet eine Sammlung von Standards,
welche die bereits genannte Problematik der fehlenden HTML Semantik mit bestehenden Webtechnologien lösen kann.
Web Components funktioniren als wiederverwendbare Web Widgets mit klar definierten Schnittstellen.
Dabei sollen sie im Browser implementiert und ohne externe Bibliotheken nutzbar sein.
Bestehende Web Komponenten sollen ohne zusätzlichen Code funktionsfähig sein. Lediglich durch das Einfügen der Komponente
in das Markup, soll bereits die komponenteninteren Funktionalität zur Verfügung stehen.
\cite[42]{Web-Component-Architecture}
Webcomponents bauen auf vier Kerntechnologien auf: HTML Imports, HTML Teamplates, Custom Elements und Shadow Dom.

\subsubsection{HTML Imports}
HTML kann in HTML Dokumente importiert und verwendet werden.
Dabei können in dem referenziertem zu importierendem HTML Abhängigkeiten in Form von CSS und JS eingebunden werden,
welche dementsprechend aufgelöst werden.
Sollten mehrere Dokumente mit der selben Abhängigkeit eingebunden werden, wird diese dennoch nur einmalig geladen.
\cite{HTMLI44:online}

\vspace{1cm}
\lstinputlisting[language=HTML,label=code,caption=HTML Imports]{kapitel2/html_import.html}
\vspace{1cm}

\subsubsection{HTML Templates}

Das HTML template-Element ermöglicht, Inhalte nicht zur Laufzeit der Website zu rendern,
sondern den Renderforgang explizit per JavaScript zu steuern. Ressourcen, wie Videos und Bilder, werden demnach
nicht initial geladen und verlängern nicht womöglich unnötig die Ladezeit der Applikation.
Inhalte des Template Tags werden zu Beginn auf Validität geprüft und stehen dann für die Verwendung im Dokument
zur Verfügung.

\subsubsection{Custom HTML Elements}

Durch Custom HTML Elements werden Webkomponenten in Applikationen eingebunden.
Eigene HTML Tags und Elemente können definiert werden und beinhalten in Javascript geschriebene Logik so wie CSS Styling.
Ein Custom Element besitzt einen Lifecycle mit diversen Einstiegspunkten:

\begin{itemize}
\item createdCallback - Element wird registriert
\item attachedCallback - Element wird in den DOM der Applikation eingefügt
\item detachedCallback - Element wird aus dem DOM entfernt
\item attributeChangedCallback - Attribute werden Element hinzugefügt, verändert oder entfernt
\end{itemize}


\subsubsection{Shadow Dom}
Shadow Dom ermöglicht Optik und Logik einer Komponente zu kapseln.
Seiteneffekte, bezüglich komponentenübergreifendem Style und Logik, werden verhindert.
Beispielsweise kann Styling eines Menüs nicht aufgrund gleicher CSS Prefixe den Style des Contents überschreiben,
da dieser in die Navigations-Komponente gekapselt ist und nicht auf die globalen Styles des Dokuments, oder anderer Elemente, zugreifen kann.
Webapplikationen lassen sich dadurch endlich paketweise organisieren und strukturieren.

\subsubsection{Vorteile}
Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.

\subsubsection{Polyfills}

Wie in Abbildung \ref{fig:platform_support} zu sehen ist, sind besagte Web Component Features nicht in
allen gängigen Browsern nativ verfügbar. Lediglich in Chrome und Opera sind diese implementiert.
Hier kommen Polyfills ins spiel. Diese implementieren fehlende Browserfeatures und gewährleisten nahezu Vollständigen
Support von unter anderem Web Components. Ein weiteres Beispiel für ein Polyfill ist core-js.
Core-JS ermöglicht die Nutzung von ES5 und ES6, auch wenn der Browser diesen Standard nicht unterstützt.

\vspace{1cm}
\begin{figure}[ht]
 \centering
 \includegraphics[width=0.8\linewidth]{kapitel2/platform_support.jpg}
 \caption{Platform Support}\cite{WebCo43:online}
 \label{fig:platform_support}
\end{figure}


\section{Typescript}

\subsection{Entwicklung von Javascript}

\begin{figure}[ht]
 \centering
 \includegraphics[width=\linewidth]{kapitel2/javascript-timeline.png}
 \caption{History of Javascript}\cite[28]{EssentialTS}
\end{figure}

Javascript wurde erstmals 1996 von Brendan Eich in einer Implementierung des Netscape Navigator Browsers eingeführt,
worauf weitere Browser die Syntax und APIs ähnlich, jedoch nicht identisch nach implementierten.
Daraufhin veröffentlichte die ECMA International einen Standard, welcher die Spezifikationen der neuen Sprache
definieren sollte. Dieser trägt den namen ECMAScript und ist der offizielle und bekannteste Standard der
Sprache. ActionScript von Macromedia und JScript von Microsoft sind weitere Implementierungen der Browsersprache,
die nicht dem ECMA Standard entsprechen, jedoch darauf aufbauen.

1997 wurde die erste Versionen des nun standardisiertem ECMAScript veröffentlicht. Ein Jahr später erschien bereits ECMAScript2,
allerdings beinhaltete dieses Update nur kleine Änderungen um einem parallel entstandenen ISO Standard von JavaScript zu implementieren.
Die nächste große Neuerung kam 1999 mit ECMAScript3, in welcher einige innovative Features implementiert wurden.
``[...]regular expressions, better string handling, new control statements, try/catch exception handling, tighter definition of errors, formatting for numeric output and other enhancements.''\cite{js-vs-es}.

Das nächste Update ECMAScript4 war 2008 geplant, zunächst als Prototyp entwickelt,
jedoch noch vor dem Release, aufgrund eines rückschritttigem Featureset wieder aufgegeben.
Zur selben Zeit entwickelte sich Ajax und damit eine völlig neue Art von dynamsichen Webapplikationen,
basierend auf JavaScript.

2009 erschien ECMAScript5, mit vollem Support in allen verbreiteten Webbrowsern, abgesehen vom Internet Explorer.
Neue Features waren unter anderem JSON support und klassische Array Funktionen wie map und forEach.
Durch die Entfernung einiger Features wurde JavaScript in der neuen Version sauberer und stabiler.

ECMAScript6 sollte bereits 2013 veröffentlicht werden, der offizielle Releasetermin wurde
dann allerdings bis in den Juni 2015 verschoben und ist bis heute noch nicht ausreichend in allen Browsern implementiert.
\cite{js-vs-es}

\subsection{Allgemein}

Typescript ist eine von Microsoft entwickelte Programmiersprache.
Die Sprache ist ein Superset von ES6, d.h. sie implementiert den JavaScript Standard und ergänzt diesen
durch zusätzliche Features, wie der statischen Typisierung.
Typescript will ausgereifter, robuster und speziell in großen Projekten eine solidere Alternative sein. \cite[28]{EssentialTS}
Zusammen mit ES6 erhalten wir gegenüber ES5 folgende Features:

\begin{figure}[ht]
 \centering
 \includegraphics[width=0.4\linewidth]{kapitel2/typescript----es5-es6-typescript-circle-diagram.png}
 \caption{Language Relationship}\cite[152]{ng-Book-2}
\end{figure}


\subsubsection{statische Typisierung}

Die wohl größte Erungenschaft der Sprache ist das statische Typsystem.
Typenfehler können in Typescript bereits zum Zeitpunkt
der Kompilierung bzw. Transpilierung erkannt werden und treten nicht erst zur Laufzeit im Browser auf.
Zudem wird Code in einer Typescript unterstützenden IDE dank Autovervollständigung
leichter zu schreiben und aussagekräftiger zu lesen.\cite[156]{ng-Book-2}

\subsubsection{Klassen}

Mit ES6 Klassen wurde eine neue Syntax für das prototypische Vererbungsmodell von Javascript entwickelt.
Dabei handelt es sich nicht um die Einführung eines neuen OOP-Modells, sondern lediglich um eine vereinfachte Syntax für Objekte und deren Schnitstellen,
so wie die Realisierung von Abstraktionen, wie man sie aus anderen Objektorientierten sprachen wie C++, Swift oder Java bereits kennt.\cite{js-Klassen}

\lstinputlisting[language=Java,label=code,caption=Klassen in ES6]{kapitel2/class.js}

\subsubsection{Module}

In ES5 gab es keinen Standard um Funktionen und Variablen in Namensräumen zu organisieren, oder dynamisch Code zu laden.
Mit ES6 wurde das fehlende Feature durch exportieren und importieren von Modulen ergänzt. Dadurch wird es sehr bequem Programmcode zu organisieren und zu laden.
Jedes ES6 Modul wird in einer eigenen Datei gespeichert. Variablen und Funktionen sind von außerhalb nicht sichtbar, es sei denn sie werden explizit exportiert.
Mittels Export lassen sich also Schnittstellen für ein Modul definieren, welche mittels des Keywords Import importiert und verwendet werden können.
In Typescript lassen sich ganze Klassendefinitionen exportieren.
Dabei ist es möglich Instanzfunktionen und Instanzvariablen mit dem Keyword private vor dem äußeren Zugriff zu verstecken.
Public Funktionen sind dann wie man es aus anderen OO-Sprachen kennt, auch von außen nutzbar.

\lstinputlisting[language=Java,label=code,caption=Export und Import von Modulen in ES6]{kapitel2/module.js}

\subsection{Transpilierung}

Typescript so wie ES6 bieten Entwicklern also eine ganze Reihe von Neuerungen gegenüber den Vorgängerversionen.
Spannende Features bringen jedoch wenig, wenn sie im Standard zwar spezifiziert wurden,
allerdings noch in sehr wenigen Browsern vollständig implementiert sind.
Um TS oder ES6 Code also überhaupt in Produktion zu nutzen, sollte er auf den ES5 oder ES3
Standard herunter transpiliert werden.
Ein Transpiler ist ein Compiler, welcher Sourcecode nicht in Maschinencode, sondern ebenfalls in Sourcecode,
allerdings einer anderen Sprache oder Version der Sprache wandelt.\cite{Introduction-to-the-Typescript-Transpiler}
In der nachfolgenden Abbildung ist zu sehen, wie Typescript Code in funktionsfähigen ES5 Code transpiliert wird.

\begin{figure}[ht]
 \centering
 \includegraphics[width=0.8\linewidth]{kapitel2/Introduction-transpiler.png}
 \caption{Transpilierung}\cite[27]{ng-Book-2}
\end{figure}
