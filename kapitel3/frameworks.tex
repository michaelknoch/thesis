%!TEX root = ../thesis.tex

\chapter{Frameworks}
\label{chap:frameworks}

Im Folgenden werden die für den praktischen Teil der Arbeit genutzten Frameworks beschrieben.
Ziel dieses Kapitels ist es, die Auswahl der genannten Frameworks zu begründen und
ihren Funktionsumfang hinsichtlich der Anforderungen des Projekts zu untersuchen.
Des weiteren sollen mögliche Alternativen evaluiert werden.


\section{AngularJS}

Angular ist derzeit eines der populärste Frontend Javascript Frameworks auf dem Markt.
Im nachfolgenden wird der Erfolg des Frameworks anhand eines Interviews mit Robin Böhm erklärt. \cite{Angu68:online}.
Böhm war einer der ersten Entwickler, der Angular 2012 in Deutschland bekannt machte.
``Zu dieser Zeit war jQuery noch die Basis des Webs. jQuery hatte aber nie den Anspruch, ein Framework für Web-Anwendungen zu sein. Der eigentliche Sinn war, die APIs der verschiedenen Browser zu vereinheitlichen.
Man musste sich deshalb immer eine eigene Architektur überlegen. Allerdings fehlte die Erfahrung, wie man große Applikationen im Web schreibt. Das führte natürlich oft zu Chaos und unwartbaren Projekten.''\cite{Angu68:online}
Böhm spricht mit Angular von einem sehr mächtigen Komplettpaket, welches Anwendungsentwicklung im Web auf ein neues Level hebe.
Gründe dafür sind die geringe Lernkurve, simple Template Syntax,
welche auf HTML aufbaut, sowie hohe Wartbarkeit aufgrund einfacher Testbarkeit von einzelnen Appkomponenten.

Wenn Böhm über Angular 2 spricht, spricht er von einem Framework für die Zukunft.
Apps, die zeitnah in Produktion gehen, würde er nach wie vor mit Angular 1 entwickeln,
da Angular2 noch nicht als Release vorliegt und interne Funktionalität auf Browserfeatures basiert,
die teilweise noch nicht in jedem Browser zur Verfügung stehen und daher durch Polyfills implementiert werden müssen.
``Somit wird Angular 2 sein ganzes Potential wohl auch erst in einigen Jahren entfalten können.
Wenn man jedoch erst heute damit anfangen würde, ein Framework für heute zu bauen,
ist es bereits veraltet, wenn es fertig ist.''\cite{Angu68:online}
Zudem sind Style Guides und Best Practise Ansätze für die Entwicklung von Applikationen mit Angular 2
noch in der Entstehung.
Dennoch spricht Böhm zuversichtlich über die Neuentwicklung des Framework.


\subsection{Neuerungen des Framework}

Angular 2 ist die Nachfolgeversion des von Google entwickelten Javascript Framework Angular 1.
Die in 2009 veröffentlichte erste Version fand großen Anklang in der Community
und wurde als Basis für dynamische Single-page-Webanwendung verschiedenster Art und Größe genutzt.
In den seit Release vergangenen Jahren hat sich die Community um das Framework immer weiter vergrößert,
welche zur stetigen Weiterentwicklung und so zu dem Erfolg von Angular1 beigetragen hat.
Das Github Repository der ersten Version hat mittlerweile 1.489 Contributors mit nahezu 7000 gestellten Pull Requests. \cite{ng1-github}

Mit Angular 2 wurden einige Grundkonzepte überarbeitet um in eine komplett neue Richtung gehen zu können.
Ziel von Google ist es, ein komponentenbasiertes leicht zu bedienendes Framework für moderne
Webanwendungen zu schaffen, welches Performanceverbesserungen und transparentere interne Strukturen als die Vorgängerversion aufweisen soll.
Eine Angular 2 Anwendung besteht daher aus einer Vielzahl diverser Komponenten, wodurch es möglich wird
Funktionalität zu kapseln, zu abstrahieren und wieder zu verwenden. Der Fokus hierbei liegt nicht nur auf Wiederverwendbarkeit innerhalb einer Codebasis.
Elemente der Anwendung sollen sowohl für den Browser, als auch für mobile Geräte sowie für native Desktop Clients genutzt werden können.
Angular 2 soll im Vergleich zu seiner Vorgängerversion leichter zu lernen und zu nutzen sein,
sowie eine solide Basis auch für komplexere Webanwendungen bieten. \cite[11-12]{Angular2}


\subsection{Komponenten}

Komponenten sind die Grundbausteine einer jeden Angular 2 Applikation und ersetzen die Direktiven aus Angular 1 nahezu vollständig.
UI und deren Funktionalität wird in Komponenten definiert.
Diese werden in Angular 2 als Typescript Klasse definiert und mit @Component dekoriert.
Der Component Decorator wird mithilfe des ES6 Imports importiert.
Der Selektor definiert den HTML Tag der Komponente, über welchen diese eingefügt und damit instanziiert wird.

Template oder TemplateUrl enthält entweder einen String mit inline Markup in angulars Template Syntax
oder eine Referenz zu einer zugehörigen HTML Datei, welche das Markup enthält.
Ebenso kann Stylesheet inline oder per Dateireferenz eingebunden werden.
Directives erwartet ein Array von in dieser Komponente zu verwenden weiteren Komponenten.
Ist eine Komponente als Directive referenziert,
kann ihr Selector im Markup der referenzierenden Komponente eingebunden,
und dadurch ihre gesamte Funktionalität genutzt werden.
Desweiteren lassen sich durch den Decorator Serviceprovider referenzieren, hierzu jedoch später mehr.

Eine Komponente besteht neben der Decorator Annotation aus einer Klasse.
Daher hat sie einen Klassennamen und mindestens einen impliziten Konstruktor.
Die Klasse wird mit dem ES6 Prefix öffentlich exportiert. Die Sichtbarkeit von Variablen und Funktionen
innerhalb der Klasse kann mithilfe der Prefixe private und public definiert werden.
Dadurch ist es möglich, Funktionalität und Daten in eine Komponente, unsichtbar für deren Verwender, zu kapseln.

\vspace{1cm}
\lstinputlisting[language=Java,label=code,caption=Basic Component]{kapitel3/basic-component.ts}
\vspace{1cm}


\subsubsection{Vererbung}

Vererbung, ein Grundkonzept der Objektorientientierung,
wird eingesetzt wenn Verhalten von verschiedenen Objekten zur Wiederverwendung
abstrahiert werden muss. Da Angular 2 Komponenten aus einer Klasse bestehen,
kann Vererbung genutzt werden um Funktionalität von Komponenten zu abstrahieren
um redundanten Code zwischen den Komponenten
zu vermeiden. Logik wird dabei von der Komponente in eine dritte Klasse ausgelagert,
welche mit dem Schlüsselwort extend als
Abstraktionsebene eingebunden wird. \cite{DanWa45:online}


\subsection{Services, Providers und Dependency Injection}

Oftmals bietet es sich an, Funktionalität von Komponenten in Services auszulagern.
Speziell wenn mehrere Komponenten auf die selben Daten,
die womöglich asynchron per HTTP geladen werden müssen, zugreifen.
Services werden ebenfalls als Klassen implementiert, welche mithilfe von \ac{DI}
als Singleton instanziiert und in die Komponenten injiziert werden können.
\ac{DI} ist ein Design Pattern, welches bereits in der ersten Version des Frameworks implementiert war.
In Angular 2 wurde \ac{DI} neu entwickel, um die Injizierung von Services in Komponenten zu ermöglichen.

\ac{DI} bringt vielerlei Vorteile mit sich. In der Implementierung einer Angular 2 Komponente wird im
Konstruktor deklariert, welche Abhängigkeiten (Dependencies) für die Komponentenfunktionalität benötigt werden.
Das Framework ist dabei für die automatische Instanziierung der Objekte verantwortlich.
Die Implementierung einer Komponente wird durch die Verwendung von \ac{DI} sehr flexibel,
da Implementierungen von Services einfach ausgetauscht werden können.
Soll beispielweise die Funktionalität einer Komponente, welche über einen Service dynamisch Daten lädt, getestet werden,
so kann die Implementierung des Services einfach ausgetauscht werden, so dass dieser statische Testdaten liefert,
sollte der Server in der Testumgebung nicht erreichbar sein.
\cite[281]{Angular2}


\vspace{0.3cm}

\begin{figure}[ht]
 \centering
 \includegraphics[width=0.8\linewidth]{kapitel3/component-injector.png}
 \caption{Component Injector}\cite[343]{Angular2}
\end{figure}
\vspace{0.3cm}

\ac{DI} wird dabei mithilfe von Providern konfiguriert.
Dies geschieht auf Komponentenebene oder im Root der Applikation.
Wird ein Service über einen Provider im Bootstrap Prozess im Root der Applikation referenziert,
so ist die Instanz des Services in jede Komponente der Applikation injizierbar.
Wird der Provider in der Komponente definiert, so ist die Serviceinstanz in dieser Komponente sowie in
allen Kindkomponenten verfügbar. Desweiteren lassen sich Provider kombinieren, da diese überschreibbar sind.
Sollte also ein Serviceprovider im Root der Applikation definiert sein, können dennoch weitere Provider in den Komponenten definiert werden.
Jedoch werden demnach auch mehrere Instanzen des Services erzeugt.
Es wäre also möglich, individuelle Singletons für bestimmte Komponentenbäume zu erzeugen. \cite[286]{Angular2}

\vspace{0.2cm}
\lstinputlisting[language=Java,label=code,caption=Provider im Bootstrap Prozess]{kapitel3/provider-example-root.ts}
\vspace{0.2cm}

\vspace{0.2cm}
\lstinputlisting[language=Java,label=code,caption=Provider in einer Komponente]{kapitel3/provider-example.ts}
\vspace{0.2cm}


\subsubsection{Services als Singletons}
\label{Services-als-Singletons}

Wie bereits erwähnt, ermöglichen \ac{DI} Provider Services als Singleton instanziieren zu können.
Dies bringt viele architektonische Vorteile mit sich. Services können auf der einen Seite genutzt werden,
um Funktionalität aus Komponenten zu abstrahieren um in weiteren Komponeten verwendet zu werden,
auf der anderen Seite können sie jedoch auch genutzt werden um Daten multiplen Komponenten zur Verfügung zu stellen.
Das Angular Framework sorgt dafür, dass ein Service nur einmalig instanziiert wird, daher erhalten alle
Komponenten, die den Service injizieren, die selbe Referenz, somit die selbe Instanz und daher die selbe globale Datenbasis.
In einem Userservice könnte beispielweise eine Boolean Variable definiert sein, welche Auskunft darüber gibt,
ob ein User eingeloggt ist, oder nicht. \cite[308]{Angular2}


\subsection{Data Binding}
Das in eine Komponente eingebundene Markup repräsentiert die Viewschicht einer Komponente.
Angular 2 besitzt zur Darstellung von Datenstrukturen eine komplexe, jedoch sehr ausdrucksstarke Template Syntax.
Variablen und Funktionen einer Komponente, können mithilfe von doppelt geschweiften Klammern in die View eingebunden werden.
Auf der Basis von HTML5 können zudem Schleifen und Fallunterscheidungen implementiert werden.
Der Gültigkeitsbereich des Templates bezieht sich, bezüglich Variablen und Funktionen, dabei auf den Kontext der Komponente,
welche das Template in der Component Decoration referenziert. \cite{Templ78:online}

\vspace{1cm}
\lstinputlisting[language=HTML,label=code,caption=Angular 2 Template Syntax]{kapitel3/template-example.html}
\vspace{1cm}

\subsection{Kommunikation}

Da eine Angular 2 Applikation auschlißelich aus Komponenten besteht, müssen diese zwangsweise miteinander
kommunizieren können. Für den Austausch von Daten stehen gibts es verschiedene Ansätze.
Wie bereits in \ref{Services-als-Singletons} erwähnt, werden Services im Normalfall als Singleton
instanziiert und in Komponenten mittels \ac{DI} injiziert. Öffentliche Servicefunktionen können hierbei für den
Austausch von Daten genutzt werden. Über den synchronen Zugriff auf Variablen hinaus,
können Events in Komponenten oder Services definiert, und von derer ebenfalls aboniert werden,
um asynchrone Kommunikation applikationsintern zu ermöglichen.

Die Auslagerung von Funktionalität in Services ergibt jedoch nur dann wirlich Sin,
wenn diese auch als Singleton existieren kann. Komponenten sind im Vergleich zu Services keine Singletons,
da sie mit jeder Verwendung in der Applikation neu instanziiert werden.
Variablen und Funktionen eingebundener Komponenten können durch die Annotationen Input und Output
direkt über den HTML Component Tag angesprochen werden. Im Normalfall werden bei der Instanziierung von Kindkomponenten
relevante Daten über den Input Tag übergeben und über den Output Kanal werden Event Emitter aboniert. \cite{Angul94:online}

Spricht man speziell von Kindkomponenten und nicht von Nachbarkomponenten,
kann mithilfer der Annotation ViewChild auf den öffentlichen Kontext der Kindkomponente zugegriffen werden.
Die Kommunikation geschieht in diesem Fall nicht über die beiden View Layer der Komponenten,
sondern direkt von der Elternkomponente zu ihrer Kindinstanz. \cite{ViewC61:online}

\subsection{Performance}

\subsubsection{Serverside Rendering}

\subsubsection{Change Detection}

Wird eine Angular2 Applikation gestartet, wird nach anfänglichem Laden der Seite eine View gerendert.
Eine interne Datenstruktur wird dabei per Templating auf eine Viewstruktur, den DOM, abgebildet und uns als Nutzer somit mittels Text,
Formularen, Buttons, Bildern etc. visuell aufbereitet.
Gibt es nun Änderungen in der Datenstruktur zur Laufzeit, muss die View dementsprechend aktualisiert werden.
Zugriffe auf den DOM sind ressourcenintensiv, daher sollten DOM Manipulationen nicht inflationär stattfinden.
Datenänderungen können entwerder durch User Events, XMLHttpRequests oder Timer (setTimeout(), setInterval()) ausgelöst werden.
Alle dies geschieht asynchron. Es ist also davon auszugehen, dass sobald eine asynchrone Aktivität innerhalb einer Komponente auftritt,
sich Daten geändert haben können und die View aktualisiert werden muss.
\cite{changedetection-explained}

\subsubsection{NgZone}

Zones sind ein internes Feature der Programmiersprache Dart. Da Dart jedoch zu JavaScript compiliert werden kann,
können Zones ebenfalls in JavaScript genutzt werden. Daher ist zone.js als Portierung für JavScript entstanden, welche in Angular2 genutzt wird.
Zones sind Ausführungskontexte, für die Observation asynchroner Operationen.
Asynchrone Funktionen werden mittels Monkey Patching überwacht und lösen in den entsprechenden Ausführungskontexten diverse Events aus.
NgZone ist ein Fork von zone.js, welcher die Basisfunktionalität um zusätzliche Events erweitert.
Change Detection relevant ist dabei das event onTurnDone().
\cite{changedetection-explained}

\vspace{0.5cm}
\textbf{``onTurnDone() - Notifies subscribers immediately after Angular’s zone is done processing the current turn and any micro tasks scheduled from that turn.''}
\cite{ZONESINANGULAR2}
\vspace{0.5cm}

Sobald das onTurnDone() Event ausgelöst wird, löst NgZone wiederum eine tick() Event aus, welches schlussendlich die Change Detection startet.
Jede Angular2 Komponente besitzt seinen eigenen Change Detector. Da eine Angular2 Applikation aus einem Komponentenbaum besteht,
kann davon ausgegangen werden, dass sie ebenfalls aus einem Baum von Change Detectoren besteht.
Change Detection wird innerhalb dieses Baumes als unidirektionaler Datenfluss von oben nach unten, beginnend mit dem Rootknoten, ausgeführt.

Obwohl jede Komponente bei einem tick() nach Änderungen prüft, ist Angular2 sehr schnell. Es können mehrere 100.000 Checks in wenigen Millisekunden durchgeführt werden,
da jede Komponenten ihren eigenen Change Detector besitzt und es nicht die eine große Instanz gibt, die alle Komponenten zeitgleich observieren muss.
Dies wird erreicht, indem Angular zur Laufzeit individuelle Change Detector Klassen für jede Komponente, entsprechend dem Datenmodell der Komponente, erzeugt.
Dieser Code kann von Virtuellen Maschinen optimiert und daher vergleichsweise schnell ausgeführt werden.

\vspace{1cm}

\begin{figure}[ht]
 \centering
 \includegraphics[width=0.7\linewidth]{kapitel3/cd-tree.jpg}
 \caption{Change Detection Flow}\cite{changedetection-explained}
\end{figure}

\newpage
\section{Ionic}

Im nachfolgenden wird die Relevanz des Frameworks Ionic 2 bezüglich des Projekts \projectname{} evaluiert.

\subsection{Einführung}

Ionic 2 ist ein Open Source \ac{SDK} für die Entwicklung mobiler Applikationen mithilfe von Angular 2 und Cordova.
Auf Basis von Webtechnologien wie HTML5, CSS3 und Javascript können Apps für iOS, Android und Windowsphone
entwickelt werden. Diese werden als hybride Apps bezeichnet,
da sie eine Mischform zwischen Web-Apps und nativen Applikationen darstellen.
Eine hybride App ist zunächste eine Webanwendung, die einen Browser für ihre Ausführung benötigt.
Als Browser wird die native Webview der jeweiligen Platform verwendet,
beispielsweise Safari für iOS und Chrome für Android.
Mithilfe von Cordova Plugins kann auf die \ac{API} des Systems zugegriffen werden um Funktionalitäten wie beispielsweise GPS, Telefonbuch und Kamera zu verwenden.
\cite{ionic34:online}

\subsection{Ionic Components}



\subsection{Ionic Native}

Ionic Native ist ein Wrapper für Cordova Module in JavaScript und Typescript.
In der Vorgängerversion des \ac{SDK} wurden Cordova Plugins installiert und als globale Singletons registriert.
Beispielsweise war es möglich aus jedem Kontext der Applikation ``navigator.camera.getPicture(onSuccess, onFail)'' aufzurufen.
Ionic Native hingegen erlaubt Entwicklern Module selektiv zu importieren, wodurch diverse Vorteile entstehen.
Globale Cordova Objekte werden vermieden, wodurch Codes deutlich strukturierter und verständlicher wird.
Zudem werden Callbacks der Cordova Plugins mit Ionic Native in Promises oder Observables gewrappt.
Dadurch entsteht ein einheitliches Interface im Stil von Angular 2 für die Nutzung dieser Module,
wodurch deren asynchrone Events bequemer observiert werden können.

Des Weiteren ist in Ionic Native eine Schicht für Fehlerbehandlung implementiert.
Ist ein Cordova Modul nicht installiert, oder wird es falsch verwendet,
generiert Ionic Native Fehler und Warnungen, die für Entwickler unabdingbar sind.
In der Vorgängerversion des Ionic \ac{SDK} konnten Fehler, die durch falsche Verwendung von
Cordova Modulen aufgetreten sind, meist nur durch ausprobieren oder Debugging des nativen Codes identifiziert werden.
\cite{Ionic55:online}

\vspace{1cm}
\lstinputlisting[language=JavaScript,label=code,caption=Ionic Native Beispiel \cite{Ionic55:online}]{kapitel3/ionic-native-example.ts}
\vspace{1cm}


\subsection{Ökosystem Ionic}

``More than code. Ionic is an ecosystem. You'll find a suite of mobile development tools and resources at your disposal that make
Ionic the complete mobile dev package. It's the best way to build apps.'' \cite{Ionic20:online}
\vspace{0.5cm}

\paragraph{Ionic \ac{CLI}}
Die Ionic \ac{CLI} vereinfacht den Umgang mit Ionic Projekten. Zunächst können individuelle
Startertemplates anhand diverser Parameter generiert werden.
Das Framework erzeugt dabei voll funktionstüchtige Applikationen, die den Einstieg in das Framework erleichtern sollen.
Sidemenu und Tabmenu sind Beispiele für diese Templates, welche in Typescript oder JavaScript generiert werden können.
Des Weiteren lassen sich Applikationen anhand der \ac{CLI} auf den Zielplattformen compilieren und auf angeschlossenen Geräten ausführen.

\paragraph{Ionic Creator}
ist ein Prototyping Tool, mit welchem Oberflächen statt
mit HTML und CSS per Mausklick kreiert werden können.
Dabei stehen von Beginn an eine Vielzahl von vorgefertigten Ionic Komponenten wie Buttons,
Label und Eingabefelder zur Verfügung.
Diese werden per Drag and Drop eingefügt und positioniert. Der Prototyp lässt sich jedrzeit
als \ac{APK} oder \ac{IPA} für dritte exportieren oder kann auf einem angeschlossenen Gerät gestartet werden.

\paragraph{Ionic Lab}
ist eine visuelle Oberfläche zur Bedienung der Ionic \ac{CLI}.
Buildvorgang, Testing und Deployment soll mithilfe der Desktop App für Mac, Windows, und
Linux speziell in Teams deutlich vereinfacht werden. \cite{Ionic75:online}

\subsubsection{Ionic Platform}

Ionic Platform ist eine Cloud, so wie eine Sammlung von Diensten für die Entwicklung,
Veröffentlichung und Skalierung von mobilen Apps. Zum Beispiel bietet Ionic Platform einen zentralen Dienst für die Handhabung von Nutzern einer App.
Diese können sich dabei klassich per Mail oder per single sign on über
Facebook, Google und Twitter registrieren und sind damit in der Applikation authentifiziert.
Zudem können registrierte Nutzer zentral in einer Weboberfläche verwaltet und ggfls. mit Push Nachrichten adressiert werden.
Diese können sich dabei an alle Nutzer, oder ein definiertes Segment wenden.
Hierzu ist kein Server mit implementiertem \ac{APN} oder \ac{GCM} System von Nöten, das Push System von Ionic deckt diese
Funktionalität bereits vollständig ab.

Zusätzlich kann die Cloud für das zentrale Deployment für alle Zielplatformen genutzt werden.
Interessant hierbei ist, dass iOS Apps generiert werden könne, auch wenn
keine macOS Umgebung zur Verfügung steht, da der Buildprozess in der Ionic Cloud stattfindet.
Ein App Update muss nicht zwingend über den Appstore der Platform geschehen,
da Änderungen, die sich nur auf den Webinhalt der App (also HTML, CSS und JS) beziehen,
beim Appstart aus der Cloud geladen werden können.
Dies ermöglicht es Apps in Echtzeit zu deployen und Appstore Review Zyklen zu vermeiden.

\subsection{Komponenten verteilen und vewenden}

Um redundanten Code zu vermeiden sollen Komponenten aus der Angular 2 Applikation in der Ionic 2 App Verwendung finden.
Hierzu soll ein möglicher Workflow entwickelt und evaluiert werden, welcher Änderungen
der Angular 2 Codebase als Updates für das Ionic Projekt propagiert.

\subsubsection{Komponenten vorbereiten}

Die zu verteilenden Komponenten sind in Typescript geschrieben,
daher müssen sie entweder im Zielprojekt in die Transpilierung mit einbezogen werden,
oder bereits vor der Verteilung transpiliert und als JavaScript Paket veröffentlicht werden.
Interessant hierbei sind die Optionen \textbf{sourceMap} und \textbf{declaration} des Typescript Transpilers.
Sind diese aktiviert, werden neben den transpilierten .js Javascript Dateien jeweils d.ts und .map Dateien abgelegt.

\paragraph{Declaration(d.ts)}

Eine d.ts Datei wird als TypeScript Declaration File bezeichnet.
Es beschreibt Implementierungen, welche in JavaScript geschrieben sind oder von TypeScript zu JavaScript transpiliert wurden.
Das Declaration File ermöglicht die Verwendung von JavaScript Code, beispielswiese einer externen Bibliothek,
in ein Projekt, welches in TypeScript geschrieben ist. Das Declaration File fungiert dabei als Interface
für die JavaScript Implementierung und gewährleistet statische Typisierung
und Autovervollständigung in unterstützenden IDEs.

Im TypeScript Transpilierungsprozess können Declaration Files mithilfe der Option \textbf{declaration} generiert werden.
Für viele populäre JavaScript Bibliotheken wurden bereits Declaration Files, von der Community oder von dem ursprünglichen Autor, nachgeliefert.
\cite[471]{EssentialTS}

\paragraph{SourceMap (.map)}

Durch die Verwendung von *-to-JavaScript Compiler/Transpiler und Minifizierungstools, ensteht ein Problem, welches SourceMaps zu lösen versuchen.
Der zur Entwicklungszeit geschriebene Code ist nicht der Selbe, welcher zur Laufzeit im Browser ausgeführt wird, da dieser transpiliert und womöglich minifiziert wurde.
Wenn nun Fehler der Applikation zur Laufzeit identifiziert werden, können diese nicht mehr auf den Ursprungscode abgebildet werden.
Der Typescript Compiler beinhaltet einen SourceMaps Generator, welcher beim Transpilevorgang .map Dateien erzeugt,
welche dabei als Referenztabelle zwischen Quell und Zielcode fungieren.
Öffnet man nun die Entwicklerkonsole in einem Browser, welcher SourceMaps unerstützt, kann man den ursprünglichen Code inspizieren.
\cite{Using97:online}


\subsubsection{Komponenten verteilen}

Es wird eine Infrastruktur benötigt um Komponenten projektübergreifend verteilen zu können.
Möglich wäre die Konfiguration von Symlinks des lokalen Dateisystems um Komponenten in das Angular,
sowie Ionic Projekt zu integrieren. Symlinks lassen sich allerdings nicht versionieren, daher würde
für jeden Entwickler, der an dem Projekt mitwirken möchte,
ein hoher initialer Konfigurationsaufwand entstehen.
Des Weiteren sollen Komponenten womöglich nicht nur in der Ionic App,
sondern in vielen weiteren auf Angular 2 basierenden Projekten wiederverwendet werden.
Eine Komponente oder ein Paket diverser Komponenten soll veröffentlicht und aktuell
gehalten werden und soll von Entwicklern genutzt werden können.

Es liegt nahe dieses Problem mithilfe eines Paketmanagers zu lösen. Angular und Ionic verwenden für das Management
ihrer Kern-Abhängigkeiten den \ac{NPM}.
Open Source Pakete können damit kostenfrei veröffentlicht und aktualisiert werden. Closed Source Pakete können
bereits für einen Aufpreis von 7\$ pro Monat genutzt werden.


\subsubsection{Komponenten verwenden}






\paragraph{HTML und CSS Inlining}
Zudem werden \ac{HTML} und \ac{CSS} referenzen der Komponente in Inline-Strings konvertiert.
Damit werden Konflikte bezüglich relativen und absoluten Referenz-Pfaden verhindert,
da diese zentral in einer Angular Applikation konfiguriert werden.
Sind Style und Markup der Komponente als Inline-String definiert,
wird diese Konfiguration bezüglich der verteilten Komponenten hinfällig.
\cite{ludoh30:online}

\begin{figure}[h]
 \centering
 \includegraphics[width=\linewidth]{kapitel3/prepare-distribution-comp.png}
 \caption{Vergleich der Development und Distribution Komponente}
\end{figure}
\vspace{0.3cm}



\subsubsection{Framework APIs}

Ionic 2 basiert auf Angular 2, dennoch unterscheiden sich diverse APIs voneinander.
Beispielsweise navigiert man durch eine Angular 2 mithilfe der Router API


\subsection{Deployment}

\section{Electron}
\subsection{Allgemein}
