%!TEX root = ../thesis.tex

\chapter{Reflexion}

Im vorherirgen Kapitel wurde die Umsetzung des praktischen Teils der Arbeit erläutert.
In diesem Kapitel wird die Technologieauswahl sowie die Implementierung
hinsichtlich der vorausgegangenen Anforderungsanalyse reflektiert.

\label{chap:reflexion}

\section{Technologieauswahl}

Mithilfe des \textbf{Angular 2 Frameworks} wurde Funktionalität von \projectname{} in Form von
Web Components implementiert.
Dadurch konnte Funktionalität, statt sie redundant implementieren zu müssen, innerhalb der
Anwendung beziehungsweise plattformübergreifend mehrfach wiederverwendet werden.
Zusätzlich wurden Komponenten die keine spezifischen Abhängigkeiten zum Projekt aufwiesen als
generische Komponenten für die Open Source Community entwickelt.

Die Wahl der Frameworks Angular 2 für die Web- und Desktop Anwendung sowie Ionic 2 für
die mobile App erwies sich als sehr gute Kombination,
da Angular Komponenten innerhalb von Ionic nahtlos verwendet werden können
und sich die APIs der beiden Frameworks sehr ähneln.

Ein zentraler Bestandteil der Implementierung ist Angulars Dependency Injection.
Komponenten müssen sich dabei nicht um die Instanziierungen von Objekten kümmern,
sondern können vom Anwendungskontext völlig entkoppelt globale Instanzen konsumieren.
Implementierungen werden dadurch deutlich flexibler und austauschbar,
sollte Funktionalität bestehender Komponenten erweitert oder überschrieben werden müssen.

Angular 2 befindet sich zum aktuellen Zeitpunkt (13. August) im fünften Release Candidate und steht damit kurz
vor dem offiziellen Release der Version 2.0. Zu beginn der Thesis befand sich das Framework im ersten Release Candidate.
Erst mit dem letzten RC5 Update des Frameworks wurden einige APIs speziell für den Bootstrap Prozess der Anwendung verändert,
zwischen den RC1 und RC4 Veröffentlichungen konnte Angular 2 ohne Änderungen am Projektcode problemlos
aktualisiert werden. Alte Implementierungen funktionieren nach wie vor in RC5,
wurden dennoch als veraltet markiert und werden vermutlich in der Version 2.0 nicht mehr
funktionieren.


\textbf{Ionic 2} befand sich zu Beginn des Projekts bereits in der siebten Beta der neuen Version.
Zum jetzigen Zeitpunkt (5. August) ist Beta 11 erscheinen, allerdings läuft die mobile App von
\projectname{} noch auf Betaversion 10, da das neuste Ionic Update,
wie so manches zuvor, Breaking Changes mit sich brachte, wodurch einige Ansichten der
mobilen Anwendungen nicht mehr ordnungsmemäß funktionierten und der neuen API hätten angepasst werden sollen.
Es wurde allerdings zunächst ein downgrade auf Beta 10 durchgeführt.

Laut offizieller Aussage von Ionic ist vor dem ersten Release Candidate noch ein weiteres Beta Update geplant.
Die letzte geplante Beta Veröffentlichung soll eine Vielzahl von interessanten
Änderungen beinhalten. Zum einen steht dem Ionic Build Prozess ein großes Update bevor.
Dieser wurde bereits in \emph{\ref{Absolute-Asset-Pfade} Absolute Asset Pfade} kritisiert und eine
mögliche Verbesserung in Form eines Pull Requests vorgelegt.
Das Problem der relativen und absoluten Pfade soll nun mit einem Technologiewechsel von \emph{Browserify} zu \emph{Webpack 2} gelöst werden.
Zusätzlich bietet \emph{Webpack 2} eine Technik welche ``tree shaking'' gennant wird.
Diese liefert dem Build Prozess Transparenz darüber, welcher \ac{CSS} und JavaScript Code tatsächlich verwendet wird.
Dadurch soll der Output sowie die Dauer des Buildvorgangs drastisch reduziert werden \cite{Annou88:online}.
Darüber hinaus will Ionic mithilfe des Ahead-of-time Compilers von Angular Templates zum Zeitpunkt des Buildvorgangs und nicht mehr zur Laufzeit kompilieren.
Dadurch soll die App deutlich an Leistung gewinnen und speziell der Start einer App soll damit drastisch verkürzt werden.

\vspace{0.3cm}

``We’re looking forward to delivering a high quality release candidate in the coming weeks,
and we want to say thank you to the community for all of the great contributions,
via GitHub issues and pull requests. It is an incredible privilege to work with such an awesome community!'' \cite{Annou88:online}

\vspace{0.3cm}

\noindent
Die 1.0.0 Version des \textbf{Electron Framework} wurde bereits am 9. Mai veröffentlicht.
Daher konnte schon zu Beginn des Projekts \projectname{} mit einer stabilen API für die Entwicklung
der Desktop Anwendung gerechnet werden, was sich in der Entwicklungsphase bestätigte.
Als sehr Zeitaufwändig stellte sich die Implementierung des automatischen
Update Mechanismus, beschrieben in \ref{client-updates} Client Aktualisierung, heraus.
Nicht weil diese Schnittstelle des Frameworks derart komplex zu bedienen ist, sondern weil der Aktualisierungsvorgang nur getestet werden kann,
wenn die Anwendung zuvor für Produktion gebaut, signiert und für den Updateserver sichtbar ins Netz geladen wurde.
Beim Start der produktions Anwendung ist es nur schwer möglich Zugriff auf nötige Debug Informationen zu erhalten,
somit verzögerte sich die Testphase von Electron AutoUpdate erheblich.


\newpage

\section{Status}

\begin{figure}[h]
 \centering
  \includegraphics[width=1\linewidth]{kapitel5/showcase.png}
 \caption{\projectname{} auf macOS, Windows und iOS}
 \label{kapitel5/cross}
\end{figure}
\vspace{0.3cm}

\noindent Die in \ref{sec:anforderungsanalyse} Anforderungsanalyse beschriebenen Ansichten können allesamt auf jeder geforderten Plattform verwendet werden.
Screenshots der Desktopanwendung sowie der mobilen App sind in \ref{screens} \emph{Screenshots Desktopanwendung und App} vorzufinden.
Das Projekt \projectname{} ist als Website, Desktop Anwendung für macOS und Windows sowie als mobile App für iOS und Android mit Vorbehalt verfügbar.
Der Vorbehalt resultiert aus dem prototypischen Status des Projekts und dem derzeit verfügbaren Budget.
Die Infrastruktur des Backend-Systems, welches in der Bachelorarbeit von \emph{Timo Weiß} beschrieben wird,
ist derzeit auf drei verschiedene \ac{AWS} Instanzen verteilt. Diese müssen für den Betrieb der Anwendung allesamt
hochgefahren werden, wodurch Kosten entstehen, die einen Rund um die Uhr Betrieb derzeit äußerst kostspielig gestalten.
Zudem liegt die derzeitige Implementierung als prototyp vor und sollte daher vor einem
öffentlichen Release zunächst als geschlossene Beta-Anwendung getestet und evaluiert werden.

Daher wurde die Entscheidung getroffen, die mobilen Anwendungen für iOS und Android zunächst noch nicht öffentlich über die jeweiligen App Stores zu vertreiben.
Die Webanwendung ist während aktivierter \ac{AWS} Instanzen öffentlich erreichbar.
Die Desktop Applikation kann jederzeit über die Github Releases heruntergeladen und gestartet werden,
allerdings steht sowohl der Web- als auch der Desktop Anwendung keine Funktionalität zur Verfügung, wenn besagte \ac{AWS}
Instanzen heruntergefahren sind.

Die komplette Cross Plattform Frontend Architektur besteht aus einem komplexen Zusammenspiel von insgesamt sechs verschiedenen Git Repositories
welche zum aktuellen Zeitpunkt Open Source verfügbar und daher vollständig einsehbar sind.

\begin{itemize}
  \item{\textbf{Web, Desktop, Komponentenentwicklung} github.com/michaelknoch/mia}
  \item{\textbf{Mobil} github.com/michaelknoch/miamobile}
  \item{\textbf{Komponenten Generator} github.com/michaelknoch/generator-ng2-comp}
  \item{\textbf{ng2-cytoscape} github.com/michaelknoch/ng2-cytoscape}
  \item{\textbf{ng2-simplegantt} github.com/michaelknoch/ng2-simplegantt}
  \item{\textbf{Desktop Update Server} github.com/michaelknoch/mia-electron-autoupdater-server}
\end{itemize}


\section{Performance}

``Technically, it’s simple. The web cannot emulate native perfectly, and it never will.
Native apps talk directly to the operating system, while web apps talk to the browser,
which talks to the OS. Thus there’s an extra layer web apps have to pass, and that makes them slightly slower and
coarser than native apps.
This problem is unsolvable.'' \cite{Webvs43:online}

\vspace{0.3cm}


\section{Ausblick}

Während der Entwicklung des Systems entstanden fortlaufend neue projektrelevante Ideen,
die weit über die definierte Anforderungsanalyse des Prototypen hinausgingen.
Aufgrund des kurzen Entwicklungszeitraums konnten viele davon werder konzipiert noch implementiert werden.
Dennoch sollen diese im folgenden genannt und hinsichtlich ihrer Chancen kurz evaluiert werden.
Im folgenden wird zwischen funktionalen und nichtfunktionalen Ideen unterschieden.

\subsection{Funktional}

\subsubsection{Momente speichern}

Während der Implementierung des \emph{Meta Pickers} kam die Idee auf, Momente zur späteren Analyse speichern zu können.
Ein Use Case bestünde darin, dass ein Anwendungsentwickler und Nutzer der Applikation \projectname{}
über die mobile App eine Push Notification auf sein Smartphone erhält, weil auf seinem System ein problematischer Sachverhalt
entstanden ist. Mithilfe der App kann er sich zunächst Übersicht verschaffen und den Zeitpunkt des Problemauftritts speichern.
Im Büro wird der gespeicherte Zeitraum dann mithilfe der Desktop Anwendung vollständig analysiert,
das Problem wird von besagtem Anwendungsentwickler im Sourcecode ausfindig gemacht, behoben und der gespeicherte Zeitpunkt wird mit ``gelöst'' Markiert.

\subsubsection{Community}

Durch die Implementierung eines Community Features könnten System mithilfe von \projectname{} im Kollektiv überwacht werden.
Systeme müssten dahingehend für weitere Nutzer freigegeben werden können.
Zusätzlich könnten diverse Kommunikationsschnittstellen für einen
Austausch zwischen den Entwicklern implementiert werden. Ein möglicher Use Case könnte auf das Feature
\emph{Momente speichern} aufbauen,
indem Momente, beziehungsweise Zeiträume, nicht nur für die eigene Analyse gespeichert werden, sondern aus der mobilen Anwendung heraus
für eine Vielzahl von Entwicklern hinterlegt werden können.
Aufgrund von kritischem Systemverhalten entstehen Diskussionen um Probleme kollegial und damit effektiver lösen zu können.

\subsection{Nichtfunktional}


\subsubsection{Unit Testing}

Spätestens dann, wenn die Anwendung aktiv genutzt werden soll, darf ihre Glaubwürdigkeit nicht aufgrund von Fehlverhalten beeinflusst werden.
Unit Tests für Angular 2 Applikationen können beispielsweise mithilfe der Testing Bibliothek \emph{Jasmine} implementiert werden.
Dabei können einzelne Komponenten, Services oder zusätzliche Klassen vollständig getestet werden \cite{Angul78:online}.
Während der Entwicklung des Prototypen \projectname{} wurde die Entwicklung von Tests aufgrund besagter Zeitroblematik vernachlässigt,
daher sollte bestehende Funktionalität nachträglich, sowie neue Features durch Unit Tests abgedeckt werden um die Qualität der Software zu gewährleisten.

\subsubsection{Continuous Deployment}

Der Build Prozess, welcher momentan Lokal auf dem Computer des Entwicklers stattfindet, könnte auf einen externen Continuous Integration (CI) Server ausgelagert werden.
Denkbar wären Services wie \emph{TravisCI}, \emph{CircleCI} oder die Konfiguration eines eigenen Jenkins Server.
Änderungen in Form von Commits auf der Master Branch könnten damit automatisch die Test- und Buildkette starten um Updates für die Desktop Anwendung sowie für die App zu generieren.
Herausforderung dabei sind die Bedienung der verschiedenen Zielplattformen, da MacOS Desktop Anwendungen nur auf MacOS und
Windows Anwendungen ebenfalls nur auf Windows Plattformen generiert und signiert werden können.
Genannte CI-Services erlauben zwar eine Emulierung verschiedener Betriebsysteme,
allerdings bedeutet dies einen hohen Konfigurationsaufwand und erfordert ein gewisses Budget für die nötige Rechenleistung.


\chapter{Fazit}

Im Rahmen dieser Arbeit entstand eine Cross Plattform Frontend Architektur für ein System,
welches die API Endpunkte der SaaS-monitoring Infrastruktur von \emph{Timo Weiß} bedient und die dort aufbereiteten Daten visualisiert.
Es wurden Chancen moderner Webtechnologien, wie Web Components und Typescript, erläutert
sowie verschiedene Frameworks und Tools hinsichtlich zuvor definierter Systemanforderungen analysiert.
Ziel war es, eine komponentenorienterte Architektur zunächst zu konzipieren und anschließend zu implementieren, um
mit geringem Programmieraufwand Produkte für möglichst viele verschiedene Plattformen erhalten zu können.
Das Frontend Projekt erhielt den Arbeitstitel \projectname{} und wurde entsprechend den beschriebenen Anforderungen
als Desktop-, Web- und Mobilanwendung entwickelt. Dabei waren die Frameworks Angular 2 und Ionic 2 von zentraler Bedeutung.

Funktionalität wurde mithilfe von Angular Komponenten innerhalb wiederverwendbarer
Elemente gekapselt und kann daher innerhalb und außerhalb der Anwendung wiederverwendet werden.
Neben der Implementierung der Komponenten wurden zudem Workflow Optimierungen und Deployment Prozesse entwickelt,
welche die Produktivität der Entwicklung drastisch gesteigert haben, wodurch es überhautp erst möglich wurde den Funktionsumfang
innerhalb der kurzen Entwicklungszeit auf derart vielvältige Weise vertreiben zu können.

In einem Ausblick wurden mögliche Chancen der Anwendung sowie erste Schritte beschrieben, die erforderlich sind um aus diesem ersten
Prototypen ein konkurenzfähiges Produkt zu schaffen.
Es bleibt abzusehen wieviel Energie und Kapazität für die Weiterentwicklung des Projekts beziehungsweise für eine definitiv im Projektplan anstehende Firmengründung zur Verfüfung steht.
Fest steht allerding, dass Softwareprojekte, die aus Eigenmotivation heraus konzipiert und entwickelt werden schnell zu einer Herzensangelegenheit werden.
