%!TEX root = ../thesis.tex

\chapter{Reflexion}

\label{chap:reflexion}

\section{Technologieauswahl}

Mithilfe des \textbf{Angular 2 Frameworks} wurde Funktionalität von \projectname{} in Form von
Web Components implementiert.
Dadurch konnte Funktionalität, statt sie redundant implementieren zu müssen, innerhalb der
Anwendung beziehungsweise plattformübergreifend mehrfach wiederverwendet werden.
Zusätzlich wurden Komponenten, die keine spezifischen Abhängigkeiten zum Projekt aufwiesen, als
generische Komponenten für die Open Source Community entwickelt.

Die Wahl der Frameworks Angular 2 für die Web- und Desktop-Anwendung sowie Ionic 2 für
die mobile App erwies sich als sehr gute Kombination,
da Angular Komponenten innerhalb von Ionic nahtlos verwendet werden können
und sich die APIs der beiden Frameworks sehr ähneln.

Ein zentraler Bestandteil der Implementierung ist Angulars Dependency Injection.
Komponenten müssen sich dabei nicht um die Instanziierungen von Objekten kümmern,
sondern können vom Anwendungskontext völlig entkoppelt globale Instanzen konsumieren.
Implementierungen werden austauschbar und damit Flexibel,
sollte Funktionalität bestehender Komponenten erweitert oder überschrieben werden müssen.

Angular 2 befindet sich zum aktuellen Zeitpunkt (13. August) im fünften Release Candidate und steht damit kurz
vor dem offiziellen Release der Version 2.0. Zu Beginn der Thesis befand sich das Framework im ersten Release Candidate.
Erst mit dem letzten RC5 Update des Frameworks wurden einige APIs speziell für den Bootstrap Prozess der Anwendung verändert,
zwischen den RC1 und RC4 Veröffentlichungen konnte Angular 2 ohne Änderungen am Projektcode problemlos
aktualisiert werden. Alte Implementierungen funktionieren nach wie vor in RC5,
wurden dennoch als veraltet markiert und werden vermutlich in der Version 2.0 nicht mehr
funktionieren.


\textbf{Ionic 2} erschien bereits zu Beginn des Projekts in der siebten Beta der neuen Version.
Zum jetzigen Zeitpunkt (13. August) ist Beta 11 erscheinen, allerdings läuft die mobile App von
\projectname{} noch auf Betaversion 10, da das neuste Ionic Update,
wie so manches zuvor, Breaking Changes mit sich brachte, wodurch einige Ansichten der
mobilen Anwendungen nicht mehr ordnungsmemäß funktionierten und der neuen API hätten angepasst werden sollen.
Es wurde allerdings zunächst ein Downgrade auf Beta 10 durchgeführt.

Laut offizieller Aussage von Ionic ist vor dem ersten Release Candidate noch ein weiteres Beta Update geplant \cite{Annou88:online}.
Die letzte geplante Beta Veröffentlichung soll eine Vielzahl von interessanten
Änderungen beinhalten. Zum einen steht dem Ionic Build Prozess ein großes Update bevor.
Dieser wurde bereits in {\ref{Absolute-Asset-Pfade} Absolute Asset Pfade kritisiert und eine
mögliche Verbesserung in Form eines Pull Requests vorgelegt.
Das Problem der relativen und absoluten Pfade soll nun mit einem Technologiewechsel von \emph{Browserify} zu \emph{Webpack 2} gelöst werden.
Zusätzlich bietet \emph{Webpack 2} eine Technik, welche ``tree shaking'' gennant wird.
Diese liefert dem Build Prozess Transparenz darüber, welcher \ac{CSS} und JavaScript Code tatsächlich verwendet wird.
Dadurch soll der Output sowie die Dauer des Buildvorgangs drastisch reduziert werden \cite{Annou88:online}.
Darüber hinaus will Ionic mithilfe des Ahead-of-time Compilers von Angular Templates zum Zeitpunkt des Buildvorgangs und nicht mehr zur Laufzeit kompilieren.
Dadurch soll die App deutlich an Leistung gewinnen und speziell der Start einer App soll damit drastisch verkürzt werden.

\vspace{0.3cm}

``We’re looking forward to delivering a high quality release candidate in the coming weeks,
and we want to say thank you to the community for all of the great contributions,
via GitHub issues and pull requests. It is an incredible privilege to work with such an awesome community!'' \cite{Annou88:online}

\vspace{0.3cm}

\noindent
Die 1.0.0 Version des \textbf{Electron Framework} wurde bereits am 9. Mai veröffentlicht.
Daher konnte schon zu Beginn des Projekts \projectname{} mit einer stabilen API für die Entwicklung
der Desktop-Anwendung gerechnet werden, was sich in der Entwicklungsphase bestätigte.
Als sehr Zeitaufwändig stellte sich die Implementierung des automatischen
Update Mechanismus, beschrieben in \ref{client-updates} Client Aktualisierung, heraus.
Nicht weil diese Schnittstelle des Frameworks derart komplex zu bedienen ist, sondern weil der Aktualisierungsvorgang nur getestet werden kann,
wenn die Anwendung zuvor für Produktion gebaut, signiert und für den Updateserver sichtbar ins Netz geladen wurde.
Beim Start der Anwendung, insofern sie für Produktion gebaut wurde, ist es nur schwer möglich, Zugriff auf nötige Debug Informationen zu erhalten,
somit verzögerte sich die Testphase von Electron AutoUpdate erheblich.


\newpage

\section{Implementierung}

\begin{figure}[h]
 \centering
  \includegraphics[width=1\linewidth]{kapitel5/showcase.png}
 \caption{\projectname{} auf macOS, Windows und iOS}
 \label{kapitel5/cross}
\end{figure}
\vspace{0.3cm}

\noindent Die in {\ref{sec:anforderungsanalyse} Anforderungsanalyse beschriebenen Ansichten können allesamt auf jeder geforderten Plattform verwendet werden.
Screenshots der Desktopanwendung sowie der mobilen App sind in \ref{screens} \emph{Screenshots Desktopanwendung und App} vorzufinden.
Das Projekt \projectname{} ist als Website, Desktop-Anwendung für macOS und Windows sowie als mobile App für iOS und Android unter Vorbehalt verfügbar.
Der Vorbehalt resultiert aus dem prototypischen Status des Projekts und dem derzeit verfügbaren Budget.
Die Infrastruktur des Backend-Systems, welches in der Bachelorarbeit von \emph{Timo Weiß} beschrieben wird,
ist derzeit auf drei verschiedene \ac{AWS} Instanzen verteilt. Diese müssen für den Betrieb der Anwendung allesamt
hochgefahren werden, wodurch Kosten entstehen, die einen Rund-um-die-Uhr-Betrieb derzeit äußerst kostspielig gestalten.
Zudem liegt die derzeitige Implementierung als prototyp vor und sollte daher vor einem
öffentlichen Release zunächst als geschlossene Beta-Anwendung getestet und evaluiert werden.

Daher wurde die Entscheidung getroffen, die mobilen Anwendungen für iOS und Android zunächst noch nicht öffentlich über die jeweiligen App Stores zu vertreiben.
Die Webanwendung ist während aktivierter \ac{AWS} Instanzen öffentlich erreichbar.
Die Desktop Applikation kann jederzeit über die Github Releases heruntergeladen und gestartet werden,
allerdings steht sowohl der Web- als auch der Desktop-Anwendung keine Funktionalität zur Verfügung, wenn besagte \ac{AWS}
Instanzen heruntergefahren sind.

Die komplette Cross Plattform Frontend Architektur besteht aus einem komplexen Zusammenspiel von insgesamt sechs verschiedenen Git Repositories,
welche zum aktuellen Zeitpunkt Open Source verfügbar sind.

\begin{itemize}
  \item{\textbf{Web, Desktop, Komponentenentwicklung} github.com/michaelknoch/mia}
  \item{\textbf{Mobil} github.com/michaelknoch/miamobile}
  \item{\textbf{Komponenten Generator} github.com/michaelknoch/generator-ng2-comp}
  \item{\textbf{ng2-cytoscape} github.com/michaelknoch/ng2-cytoscape}
  \item{\textbf{ng2-simplegantt} github.com/michaelknoch/ng2-simplegantt}
  \item{\textbf{Desktop Update Server} github.com/michaelknoch/mia-electron-autoupdater-server}
\end{itemize}

\section{Performanz von Web-Apps}

Hybride Web-Apps haben gegenüber nativ entwickelten Anwendungen einen großen Nachteil.
Native Anwendungen sprechen direkt mit dem Betriebssystem, während Web-Apps
über die Schnittstellen des Browsers mit dem System kommunizieren müssen.
Hybride Web-Apps müssen also eine zusätzliche Kommunikationsschicht durchlaufen,
wodurch speziell der Rendervorgang der Ansichten sowie die Ausführung von Animationen verlangsamt wird \cite{Webvs43:online}.
Native Anwendungen weisen daher in den meisten Fällen eine höhere Performanz auf und wirken deutlich
smoother.

Die tatsächliche Funktionalität von \projectname{} besteht hauptsächlich aus statischen Ansichten, ohne Effekte und
rechenintensive Animationen. Lediglich die Willkommens-Ansicht der Desktop- und Webanwendung,
sowie die Viewwechsel der mobilen App enthalten Animationen, welche allerdings nicht auf der CPU,
sondern mithilfe der Hardwarebeschleunigung auf der GPU des Geräts berechnet.
Dadurch kann die Bildrate der Animationen vergleichsweise hoch gehalten werden.
Die mobile App wurde auf einem Nexus 5x, Iphone 6, Iphone 4s und Nexus 5 getestet.
Auf dem Nexus 5x und Iphone 6 scheint die App durchgehend eine stabile Bildrate zu haben,
wird die App auf den beiden älteren Modellen ausgeführt,
so fallen bei intensiver Benutzung vergleichsweise niedrige
Bildraten speziell bei der Animation der Viewwechsel auf.
Die App wirkt dadurch etwas schwammiger, als bei den neueren Geräten.

Die Frameraten der Web- und Desktop-Anwendungen wurden mithilfe der
Chrome Developer Tools auf einem Macbook Pro mit einem Intel i7 Prozessor und Intel HD 4000 Grafik gemessen,
siehe \ref{profiling} Bootstrap Timeline - Chrome Developer Tools.
Deutlich wurde, dass beide Anwendungen die Animation, welche nach dem Start der Anwendung ausgeführt wird,
mit konstanten 60 FPS darstellen können. Dieser Test wurde ebenfalls auf einem Windows Desktop-Rechner mit einem Intel i5 Prozessor und Nvidia 745GTX Grafik durchgeführt und
erzielte vergleichbare Ergebnisse. Des Weiteren ist in den Abbildungen \emph{\ref{bootstrap-web} Bootstrap Timeline Web} und \emph{\ref{bootstrap-desktop} Bootstrap Timeline Desktop} zu erkennen,
wie die Hardwarebeschleunigung die Berechnung der Animation von der CPU auf die GPU auslagert.
Es ist davon auszugehen, dass Electron eine ähnliche Leistungsumgebung wie der Chrome Browser bieten kann und
einfache Animationen, wie sie immer häufiger in modernen Webanwendungen auftreten, zumindest auf zeitgemäßen Systemen keine
sichtbaren Performance Einbrüche verursachen.

Bei der Entwicklung von hybriden Applikation sollte bedacht werden,
auf welchen Geräten beziehungsweise innerhalb welcher Gerätegeneration eine Anwendung performant benutzbar sein muss,
da die tatsächliche Leistung von der Webview des ausführenden Systems abhängt.
Darüber hinaus weisen die Webviews der verschiedenen Geräte unterschiede in den Implementierungen
des JavaScript und \ac{CSS} Standards auf. Demnach muss für stabilen plattformübergreifenden Betrieb sorgfältig geprüft werden,
ob Funktionalität innerhalb adressierter Webviews überhaupt für die Implementierung zur Verfügung steht.
Während der iOS Gerätemarkt und damit die Vielfalt der Webviews von Iphones, Ipads und Ipods noch überschaubar ist,
so lässt sich vergleichsweise nur schwerw festlegen, welche Android Webview tatsächlich erreicht werden muss,
da diese bei Android Geräten nicht nur mit der Version des Betriebssystems, sondern auch mit dem Hersteller des Geräts variieren kann.

Abhilfe dafür schafft das \emph{Crosswalk Projekt}, welches das Problem des fragmentierten Android Marktes lösen will,
indem eine Chromium Webview in die Binärdatei der App compiliert wird. Dadurch kann sichergestellt werden,
dass neuste Browser APIs für die Implementierung der Anwendung genutzt werden könnnen \cite{Cross69:online}.
Allerdings vergrößert sich dadurch die Größe der \ac{APK} sowie der auf dem Gerät benötigte Speicher erheblich.

Cordova Apps laufen auf iOS Geräten in der UIWebView, einer nativen Webview von Apple. Safari basiert bereits
auf der neuen, stabileren und schnelleren WKWebView, wodurch erklärt wird, wieso Web-Apps in Safari
mehr Leistung aufweisen und flüssiger wirken, als hybride Cordova Apps die noch im Kontext der alten UIWebView ausgeführt werden.
Das Ionic Team beschäftigt sich derzeit damit die neue Webview für Ionic 1 sowie Ionic 2 als Ausführungskontext verwenden zu können.
Erste Tests zeigten bereits deutlich reduzierte Ram-Auslastungen sowie kürzere Startzeiten und mehr Performanz von Ionic Apps auf iOS Geräten \cite{Cordo84:online}.


\section{Ausblick}

Während der Entwicklung des Systems entstanden fortlaufend neue projektrelevante Ideen,
die weit über die definierte Anforderungsanalyse des Prototypen hinausgehen.
Aufgrund des kurzen Entwicklungszeitraums konnten viele davon weder konzipiert noch implementiert werden.
Dennoch sollen diese genannt und hinsichtlich ihrer Chancen kurz evaluiert werden.
Hierbei wird zwischen funktionalen und nichtfunktionalen Ideen unterschieden.

\subsection{Funktional}

\subsubsection{Momente speichern}

Während der Implementierung des \emph{Meta Pickers} kam die Idee auf, Momente zur späteren Analyse speichern zu können.
Ein Use Case bestünde darin, dass ein Anwendungsentwickler und Nutzer der Applikation \projectname{}
über die mobile App eine Push Notification auf sein Smartphone erhält, weil auf seinem System ein problematischer Sachverhalt
entstanden ist. Mithilfe der App kann er sich zunächst Übersicht verschaffen und den Zeitpunkt des Problemauftritts speichern.
Im Büro wird der gespeicherte Zeitraum dann mithilfe der Desktop-Anwendung vollständig analysiert,
das Problem wird von besagtem Anwendungsentwickler im Sourcecode ausfindig gemacht, behoben und der gespeicherte Zeitpunkt wird mit ``gelöst'' Markiert.

\subsubsection{Community}

Durch die Implementierung eines Community Features könnten System mithilfe von \projectname{} im Kollektiv überwacht werden.
Systeme müssten dahingehend für weitere Nutzer freigegeben werden können.
Zusätzlich könnten diverse Kommunikationsschnittstellen für einen
Austausch zwischen den Entwicklern implementiert werden. Ein möglicher Use Case könnte auf das Feature
\emph{Momente speichern} aufbauen,
indem Momente, beziehungsweise Zeiträume, nicht nur für die eigene Analyse gespeichert, sondern aus der mobilen Anwendung heraus
für eine Vielzahl von Entwicklern hinterlegt werden können.
Aufgrund von kritischem Systemverhalten entstehen Diskussionen, um Probleme kollegial und damit effektiver lösen zu können.

\subsection{Nichtfunktional}


\subsubsection{Unit Testing}

Spätestens dann, wenn die Anwendung aktiv genutzt werden soll, darf ihre Glaubwürdigkeit nicht aufgrund von Fehlverhalten beeinflusst werden.
Unit Tests für Angular 2 Applikationen können beispielsweise mithilfe der Testing Bibliothek \emph{Jasmine} implementiert werden.
Dabei können einzelne Komponenten, Services oder zusätzliche Klassen vollständig getestet werden \cite{Angul78:online}.
Während der Entwicklung des Prototypen \projectname{} wurde die Entwicklung von Tests aufgrund besagter Zeitroblematik vernachlässigt,
daher sollte bestehende Funktionalität nachträglich sowie neue Features durch Unit Tests abgedeckt werden, um die Qualität der Software zu gewährleisten.

\subsubsection{Continuous Deployment}

Der Build Prozess, welcher momentan Lokal auf dem Computer des Entwicklers stattfindet, könnte auf einen externen Continuous Integration (CI) Server ausgelagert werden.
Denkbar wären Services wie \emph{TravisCI}, \emph{CircleCI} oder die Konfiguration eines eigenen Jenkins Server.
Änderungen in Form von Commits auf der Master Branch könnten damit automatisch die Test- und Buildkette starten, um Updates für die Desktop-Anwendung sowie für die App zu generieren.
Herausforderung dabei ist die Bedienung der verschiedenen Zielplattformen, da MacOS Desktop-Anwendungen nur auf MacOS und
Windows Anwendungen ebenfalls nur auf Windows Plattformen generiert und signiert werden können.
Genannte CI-Services erlauben zwar eine Emulierung verschiedener Betriebsysteme,
allerdings bedeutet dies einen hohen Konfigurationsaufwand und erfordert ein gewisses Budget für die nötige Rechenleistung.


\chapter{Fazit}

Im Rahmen dieser Arbeit entstand eine Cross-Plattform Frontend Architektur für ein System,
welches die API Endpunkte der SaaS-monitoring Infrastruktur von \emph{Timo Weiß} bedient und die dort aufbereiteten Daten visualisiert.
Es wurden Chancen moderner Web-Technologien wie Web Components und Typescript erläutert
sowie verschiedene Frameworks und Tools hinsichtlich zuvor definierter Systemanforderungen analysiert.
Ziel war es, eine komponentenorienterte Architektur zunächst zu konzipieren und anschließend zu implementieren, um
mit geringem Programmieraufwand Produkte für möglichst viele verschiedene Plattformen erhalten zu können.
Das Frontend Projekt erhielt den Arbeitstitel \projectname{} und wurde entsprechend den beschriebenen Anforderungen
als Desktop-, Web- und Mobilanwendung entwickelt.

Funktionalität wurde mithilfe von Angular Komponenten innerhalb wiederverwendbarer
Elemente gekapselt und kann daher innerhalb und außerhalb der Anwendung wiederverwendet werden.
Neben der Implementierung der Komponenten wurden zudem Workflow Optimierungen und Deployment Prozesse entwickelt,
welche die Produktivität der Entwicklung drastisch gesteigert haben, wodurch es überhautp erst möglich wurde den Funktionsumfang
innerhalb der kurzen Entwicklungszeit auf derart vielvältige Weise vertreiben zu können.

Innerhalb der Reflexion wurden mögliche Chancen der verwendeten Technologien und der Anwendung selbst beschrieben
sowie mögliche erste Schritte genannt, die erforderlich sind um aus diesem ersten
Prototypen ein konkurenzfähiges Produkt zu schaffen.
Abschließend lässt sich sagen, dass die umfangreiche Frontend Architektur nur anhand des webbasierten Cross-Plattform Ansatzes und der Synergien zwischen den verwendeten Technologien umgesetzt werden konnte.
Ein nativer Ansatz hätte zwar deutliche Performanz Vorteile mit sich gebracht, jedoch wäre dann die Implementierung und Wartung der Anwendungen demnach um ein vielfaches zeitintensiver.
Bei der Entwicklung webbasierter Cross-Plattform Apps muss stets bedacht werden, welche Funktionalität für welche Gerätegeneration entwickelt wird.
Rechenintensive Animationen lassen sich, speziell auf älteren Systemen, nur schwer performant einsetzen und viele moderne Webstandards stehen älteren Webviews nicht zur Verfügung.
Die Technologien der Webentwicklung sowie die Gerätetechnologien selbst werden sich in den kommenden Jahren stetig weiterentwickeln. Es gibt bereits eine Vielzahl von Ansätzen, die das Leistungsproblem von webbasierten Anwendungen reduzieren können,
es bleibt also abzusehen, wie sich diese spannende Technologie in der Zukunft entwickeln wird.
Ferner bleibt abzusehen wieviel Energie und Kapazität für die Weiterentwicklung des Projekts \projectname{} beziehungsweise für eine definitiv im Projektplan anstehende Firmengründung zur Verfüfung steht.
Fest steht allerding, dass Softwareprojekte, die aus Eigenmotivation heraus konzipiert und entwickelt werden schnell zu einer Herzensangelegenheit werden.
